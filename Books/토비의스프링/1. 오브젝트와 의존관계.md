# 1. 오브젝트와 의존관계

## Intro

스프링은 객체지향 프로그래밍 언어인 자바를 기반으로 만들어졌다. 스프링의 철학은 객체지향 프로그래밍이 제공하는 폭넓은 혜택을 누릴 수 있도록 기본으로 돌아가자는 것이다.

스프링이 가장 관심을 두는 대상은 오브젝트이며 스프링을 이해하기 위해서는 오브젝트에 깊은 관심을 가져야 한다.

오브젝트에 대한 관심은 오브젝트의 설계로 발전하게 되고 객체지향 설계의 기초와 원칙을 비롯해서, 디자인패턴, 리팩토링, 단위 테스트 같은 오브젝트 설계와 구현에 관한 여러 가지 응용 기술과 지식이 요구된다.

스프링은 오브젝트를 어떻게 효과적으로 설계, 구현, 개선하는 방법에 대한 명쾌한 기준을 제공함과 동시에 객체지향 기술과 설계, 구현에 관한 베스트 프랙티스를 자연스레 적용할 수 있도록 프레임워크 형태로 제공한다.

## 1.1 초난감 DAO

```java
public class UserDao {

    public void add(User user) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "example",
            "1234");

        PreparedStatement ps = c.prepareStatement(
            "insert into users(id, name, password) values (?,?,?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        c.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "example",
            "1234");

        PreparedStatement ps = c.prepareStatement(
            "select * from users where id = ?");
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        c.close();

        return user;
    }
}
```

User 정보를 추가하고 가져오는 기능을 잘 수행하고 있지만, 많은 잠재적인 문제를 가지고 있다. 대체 뭐가 문제일까?

## 1.2 DAO의 분리

### 1.2.1 관심사 분리

소프트웨어는 끊임없이 변하기 때문에 개발자는 언제 다가올지 모르는 변화에 대비해야 한다.

변화를 대비하기 위한 가장 좋은 대책은 변화의 폭을 최소화하는 것이다.

변경이 생겼을 때 작업을 최소화하고, 사이드 이펙을 줄이기 위해서는 분리와 확장을 고려한 설계가 필요하다.

관심사가 같은 것끼리 모으고 관심사가 다른 것들은 분리하면 같은 관심에게 더 효과적으로 집중할 수 있다.

### 1.2.2 커넥션 만들기의 추출
예제의 `add()`, `get()` 메서드에서 DB 연결을 위해 Connection 오브젝트를 가져오는 부분이 중복되는 것을 확인할 수 있다.  

이는 곧 두 메서드 간의 중복된 관심사이자, 해당 메서드의 다른 비즈니스(등록, 조회)와는 다른 관심사이다.

또한, 등록 조회뿐 아니라 수정, 삭제 등 여러 기능이 확장될 수 있는데 지금처럼 중복된 코드를 남발할 수는 없다.

따라서, DB 커넥션을 가져오는 메서드를 추출하여 관심사를 분리한 결과 계정 정보 변경 등 해당 관심사에 변경이 필요하면, 그 부분만 바꾸면 된다.

### 1.2.3 DB 커넥션 만들기의 독립
만약 UserDao를 외주 주어야 하는 상황이라면? DB 연결에 대한 책임은 각 벤더사에 맡기고, 그 외 코드는 자사의 재산이므로 숨겨야 한다면?

이전에 분리한 `getConnection()` 메서드를 추상 메서드로 변경하면, 상속하는 구현체가 해당 메서드를 재정의하여 DB 연결을 하는 방식으로 상속을 통한 확장이 가능해진다. (템플릿 메서드 패턴)

상속을 통해 확장에 무사히 성공했지만, 아쉽게도 상속을 사용했기에 단점을 갖고 있다.

다중상속이 안되는데, UserDao가 이미 다른 클래스를 상속하고 있을 수 있고, 슈퍼 클래스와 서브 클래스 간의 결합도가 너무 높다는 단점이 있다.


## 1.3 DAO의 확장
추상 클래스를 상속하여 변화의 성격이 다른 것을 분리하였고 결과적으로 서로 영향을 주지 않으며 필요한 시점에 독립적으로 변경할 수 있게 만들었다.

하지만 상속을 사용했기에 앞서 말했던 단점을 갖고 있어 찝찝함을 지울 수 없으니 더 개선해보자.

### 1.3.1 클래스 분리
완전히 독립적인 클래스로 분리하고, 상속(extends) 대신 조합(composition)을 사용했다.

분리에 성공했지만, 아직 아래에서 설명하는 두 가지 문제점이 존재한다.

첫째는 메서드명이 변경된다면 모두 변경해주어야 하는 수고스러움이 발생한다.

두번째는 UserDAO가 DB 커넥션 클래스에 대해 너무 많이 알고 있다.

즉, 관심사가 다른 클래스에게 종속적이게 되어 자유로운 확장이 어렵다.

### 1.3.2 인터페이스 도입
두 클래스 중간에 추상적인 느슨한 연결고리를 만들어 해결이 가능하다. 느슨한 연결고리? 추상적이다. 아래에서 살펴보자.

자바에는 추상화를 도와주는 유용한 도구인 인터페이스가 있다.

인터페이스는 어떤 일을 하겠다는 명세만 있고, 구현체에 대한 정보는 모두 감춰버린다.

오브젝트를 만들기 위해 클래스가 아닌 인터페이스를 통한다면 실제 구현 클래스에 대해 신경쓸 필요가 없고, 변경되어도 마찬가지이다.
그저 인터페이스에 정의된 기능만 사용하면 된다.

다시 정리하자면, 인터페이스를 사용한다면 메서드의 기능만 관심을 갖지, 그 기능이나 구현체에 대한 관심은 필요가 없다.

```java
public class UserDao {
    
    private ConnectionMaker connectionMaker;
    
    public UserDao(){
        this.connectionMaker = new DConnectionMaker();
    }
}

```

어찌저찌해서 인터페이스를 사용해서 일관성을 띄고, 확장성을 높인 것 같긴하다. 

하지만 UserDao의 생성자를 보면 결국 D사의 DB 커넥션 클래스에 직접적으로 의존하고 있다. 

만약 커넥션 기능에 변경이 생겼다면, UserDao를 손봐야한다는 것이다. 그렇다면 더 개선해보자.

### 1.3.3 관계설정 책임의 분리
아직까지 UserDao가 구체적인 클래스에 대해 알고 있는 이유는, UserDao 내부에 분리되지 못한 관심사항이 존재하고 있기 때문이다.

그 관심사는 바로 UserDao가 어떤 인터페이스의 구현체 사용을 선택할 것인지이다.

다시 말해 UserDao와 구체 클래스 사이의 관계를 설정해주는 것에 관한 관심이다. 이를 분리해야 아름답게 확장할 수 있다.

UserDao의 클라이언트가 적어도 하나는 존재한다. 여기서 클라이언트는 UserDao를 사용하는 오브젝트를 의미한다.

클라이언트 오브젝트가 UserDao와 ConnectionMaker 구현 클래스 관계를 결정해주는 기능을 분리해서 두기 적절한 곳이다.

오브젝트 사이의 관계가 형성되기 위해서는 만들어진 오브젝트가 있어야 한다.

생성자를 직접 호출해 만드는 방법도 있지만 오브젝트는 메서드 파라미터 등을 통해 전달 가능하니 외부에서 만들어진 것을 가져오는 방법도 있다.

그렇게 파라미터로 제공받은 오브젝트가 파라미터의 인터페이스에 구현체라면 어떤 클래스인지 신경쓰지 않아도 된다.

이를 통해 런타임 시에 오브젝트 사이의 관계가 맺어진다.

D사든 N사든 B사든 클라이언트에서 적절한 구현 클래스의 의존관계만 맺어주면 된다.

따라서, DB 접근 방식이나 코드에 변경이 생기더라도 UserDao는 영향이 없으며, 추가적으로도 자유로운 확장이 가능하다.

### 1.3.4 원칙과 패턴

#### 개방 폐쇄 원칙(OCP)
OCP를 간단히 정의하면 "확장에는 열려있고 변경에는 닫혀있어야 한다" 이다.

벤더사가 늘더라도, UserDao에 변경을 주지 않고 ConnectionMaker만 추가하여 확장할 수 있다.

인터페이스를 통해 제공되는 확장 포인트는 확장을 위해 개방되어 있고, 인터페이스를 이용하는 클래스는 굳게 폐세되어 있다.

well-design OOP class는 OCP를 잘 준수하고 있다.


#### 높은 응집도와 낮은 결합도
응집도가 높다는 것은 하나의 모듈, 클래스가 단일 책임 또는 관심사에 집중하고 있다는 의미이다.
불필요하거나 직접 관련이 없는 외부 관심과 책임이 얽혀있지 않고, 공통 관심사끼리만 모여있다.


책임과 관심사가 다른 오브젝트 또는 모둘과는 낮은 결합도, 즉 느슨하게 연결해주는 것이 바람직하다.
느슨한 연결은 관계를 유지하기 위해 꼭 필요한 최소한의 방법만 간접적으로 제공하고, 그 외에는 독립적이고 알 필요가 없게 만들어주는 것이다.
결합도가 낮아지면 변화 대응 속도가 높아지고, 구성이 깔끔해지며 확장에도 편리하다.

결합도가 높아지면 변경에 따르는 비용과 버그가 발생할 가능성이 높아진다.

UserDao와 ConnectionMaker는 인터페이스를 통해 아주 느슨하게 연결되어 있는 상태이다.
UserDao는 구체적인 ConnectionMaker 구현 클래스에 대해 전혀 몰라도 된다.