# 1. 오브젝트와 의존관계

## Intro

스프링은 객체지향 프로그래밍 언어인 자바를 기반으로 만들어졌다. 스프링의 철학은 객체지향 프로그래밍이 제공하는 폭넓은 혜택을 누릴 수 있도록 기본으로 돌아가자는 것이다.

스프링이 가장 관심을 두는 대상은 오브젝트이며 스프링을 이해하기 위해서는 오브젝트에 깊은 관심을 가져야 한다.

오브젝트에 대한 관심은 오브젝트의 설계로 발전하게 되고 객체지향 설계의 기초와 원칙을 비롯해서, 디자인패턴, 리팩토링, 단위 테스트 같은 오브젝트 설계와 구현에 관한 여러 가지 응용 기술과 지식이 요구된다.

스프링은 오브젝트를 어떻게 효과적으로 설계, 구현, 개선하는 방법에 대한 명쾌한 기준을 제공함과 동시에 객체지향 기술과 설계, 구현에 관한 베스트 프랙티스를 자연스레 적용할 수 있도록 프레임워크 형태로 제공한다.

## 1.1 초난감 DAO

```java
public class UserDao {

    public void add(User user) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "example",
            "1234");

        PreparedStatement ps = c.prepareStatement(
            "insert into users(id, name, password) values (?,?,?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        c.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "example",
            "1234");

        PreparedStatement ps = c.prepareStatement(
            "select * from users where id = ?");
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        c.close();

        return user;
    }
}
```

User 정보를 추가하고 가져오는 기능을 잘 수행하고 있지만, 많은 잠재적인 문제를 가지고 있다. 대체 뭐가 문제일까?

## 1.2 DAO의 분리

### 1.2.1 관심사 분리

소프트웨어는 끊임없이 변하기 때문에 개발자는 언제 다가올지 모르는 변화에 대비해야 한다.

변화를 대비하기 위한 가장 좋은 대책은 변화의 폭을 최소화하는 것이다.

변경이 생겼을 때 작업을 최소화하고, 사이드 이펙을 줄이기 위해서는 분리와 확장을 고려한 설계가 필요하다.

관심사가 같은 것끼리 모으고 관심사가 다른 것들은 분리하면 같은 관심에게 더 효과적으로 집중할 수 있다.

### 1.2.2 커넥션 만들기의 추출
예제의 `add()`, `get()` 메서드에서 DB 연결을 위해 Connection 오브젝트를 가져오는 부분이 중복되는 것을 확인할 수 있다.  

이는 곧 두 메서드 간의 중복된 관심사이자, 해당 메서드의 다른 비즈니스(등록, 조회)와는 다른 관심사이다.

또한, 등록 조회뿐 아니라 수정, 삭제 등 여러 기능이 확장될 수 있는데 지금처럼 중복된 코드를 남발할 수는 없다.

따라서, DB 커넥션을 가져오는 메서드를 추출하여 관심사를 분리한 결과 계정 정보 변경 등 해당 관심사에 변경이 필요하면, 그 부분만 바꾸면 된다.

### 1.2.3 DB 커넥션 만들기의 독립
만약 UserDao를 외주 주어야 하는 상황이라면? DB 연결에 대한 책임은 각 벤더사에 맡기고, 그 외 코드는 자사의 재산이므로 숨겨야 한다면?

#### 상속을 통한 확장
이전에 분리한 `getConnection()` 메서드를 추상 메서드로 변경하면, 상속하는 구현체가 해당 메서드를 재정의하여 DB 연결을 하는 방식으로 상속을 통한 확장이 가능해진다. (템플릿 메서드 패턴)

상속을 통해 확장에 무사히 성공했지만, 아쉽게도 상속을 사용했기에 단점을 갖고 있다.

다중상속이 안되는데, UserDao가 이미 다른 클래스를 상속하고 있을 수 있고, 슈퍼 클래스와 서브 클래스 간의 결합도가 너무 높다는 단점이 있다.  