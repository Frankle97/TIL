# 1. 오브젝트와 의존관계

## Intro

스프링은 객체지향 프로그래밍 언어인 자바를 기반으로 만들어졌다. 스프링의 철학은 객체지향 프로그래밍이 제공하는 폭넓은 혜택을 누릴 수 있도록 기본으로 돌아가자는 것이다.

스프링이 가장 관심을 두는 대상은 오브젝트이며 스프링을 이해하기 위해서는 오브젝트에 깊은 관심을 가져야 한다.

오브젝트에 대한 관심은 오브젝트의 설계로 발전하게 되고 객체지향 설계의 기초와 원칙을 비롯해서, 디자인패턴, 리팩토링, 단위 테스트 같은 오브젝트 설계와 구현에 관한 여러 가지 응용 기술과 지식이 요구된다.

스프링은 오브젝트를 어떻게 효과적으로 설계, 구현, 개선하는 방법에 대한 명쾌한 기준을 제공함과 동시에 객체지향 기술과 설계, 구현에 관한 베스트 프랙티스를 자연스레 적용할 수 있도록 프레임워크 형태로 제공한다.

## 1.1 초난감 DAO

```java
public class UserDao {

    public void add(User user) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "example",
            "1234");

        PreparedStatement ps = c.prepareStatement(
            "insert into users(id, name, password) values (?,?,?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        c.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "example",
            "1234");

        PreparedStatement ps = c.prepareStatement(
            "select * from users where id = ?");
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        c.close();

        return user;
    }
}
```

User 정보를 추가하고 가져오는 기능을 잘 수행하고 있지만, 많은 잠재적인 문제를 가지고 있다. 대체 뭐가 문제일까?

## 1.2 DAO의 분리

### 1.2.1 관심사 분리

소프트웨어는 끊임없이 변하기 때문에 개발자는 언제 다가올지 모르는 변화에 대비해야 한다.

변화를 대비하기 위한 가장 좋은 대책은 변화의 폭을 최소화하는 것이다.

변경이 생겼을 때 작업을 최소화하고, 사이드 이펙을 줄이기 위해서는 분리와 확장을 고려한 설계가 필요하다.

관심사가 같은 것끼리 모으고 관심사가 다른 것들은 분리하면 같은 관심에게 더 효과적으로 집중할 수 있다.

### 1.2.2 커넥션 만들기의 추출
예제의 `add()`, `get()` 메서드에서 DB 연결을 위해 Connection 오브젝트를 가져오는 부분이 중복되는 것을 확인할 수 있다.  

이는 곧 두 메서드 간의 중복된 관심사이자, 해당 메서드의 다른 비즈니스(등록, 조회)와는 다른 관심사이다.

또한, 등록 조회뿐 아니라 수정, 삭제 등 여러 기능이 확장될 수 있는데 지금처럼 중복된 코드를 남발할 수는 없다.

따라서, DB 커넥션을 가져오는 메서드를 추출하여 관심사를 분리한 결과 계정 정보 변경 등 해당 관심사에 변경이 필요하면, 그 부분만 바꾸면 된다.

### 1.2.3 DB 커넥션 만들기의 독립
만약 UserDao를 외주 주어야 하는 상황이라면? DB 연결에 대한 책임은 각 벤더사에 맡기고, 그 외 코드는 자사의 재산이므로 숨겨야 한다면?

이전에 분리한 `getConnection()` 메서드를 추상 메서드로 변경하면, 상속하는 구현체가 해당 메서드를 재정의하여 DB 연결을 하는 방식으로 상속을 통한 확장이 가능해진다. (템플릿 메서드 패턴)

상속을 통해 확장에 무사히 성공했지만, 아쉽게도 상속을 사용했기에 단점을 갖고 있다.

다중상속이 안되는데, UserDao가 이미 다른 클래스를 상속하고 있을 수 있고, 슈퍼 클래스와 서브 클래스 간의 결합도가 너무 높다는 단점이 있다.


## 1.3 DAO의 확장
추상 클래스를 상속하여 변화의 성격이 다른 것을 분리하였고 결과적으로 서로 영향을 주지 않으며 필요한 시점에 독립적으로 변경할 수 있게 만들었다.

하지만 상속을 사용했기에 앞서 말했던 단점을 갖고 있어 찝찝함을 지울 수 없으니 더 개선해보자.

### 1.3.1 클래스 분리
완전히 독립적인 클래스로 분리하고, 상속(extends) 대신 조합(composition)을 사용했다.

분리에 성공했지만, 아직 아래에서 설명하는 두 가지 문제점이 존재한다.

첫째는 메서드명이 변경된다면 모두 변경해주어야 하는 수고스러움이 발생한다.

두번째는 UserDAO가 DB 커넥션 클래스에 대해 너무 많이 알고 있다.

즉, 관심사가 다른 클래스에게 종속적이게 되어 자유로운 확장이 어렵다.

### 1.3.2 인터페이스 도입
두 클래스 중간에 추상적인 느슨한 연결고리를 만들어 해결이 가능하다. 느슨한 연결고리? 추상적이다. 아래에서 살펴보자.

자바에는 추상화를 도와주는 유용한 도구인 인터페이스가 있다.

인터페이스는 어떤 일을 하겠다는 명세만 있고, 구현체에 대한 정보는 모두 감춰버린다.

오브젝트를 만들기 위해 클래스가 아닌 인터페이스를 통한다면 실제 구현 클래스에 대해 신경쓸 필요가 없고, 변경되어도 마찬가지이다.
그저 인터페이스에 정의된 기능만 사용하면 된다.

다시 정리하자면, 인터페이스를 사용한다면 메서드의 기능만 관심을 갖지, 그 기능이나 구현체에 대한 관심은 필요가 없다.

```java
public class UserDao {
    
    private ConnectionMaker connectionMaker;
    
    public UserDao(){
        this.connectionMaker = new DConnectionMaker();
    }
}

```

어찌저찌해서 인터페이스를 사용해서 일관성을 띄고, 확장성을 높인 것 같긴하다. 

하지만 UserDao의 생성자를 보면 결국 D사의 DB 커넥션 클래스에 직접적으로 의존하고 있다. 

만약 커넥션 기능에 변경이 생겼다면, UserDao를 손봐야한다는 것이다. 그렇다면 더 개선해보자.

### 1.3.3 관계설정 책임의 분리
아직까지 UserDao가 구체적인 클래스에 대해 알고 있는 이유는, UserDao 내부에 분리되지 못한 관심사항이 존재하고 있기 때문이다.

그 관심사는 바로 UserDao가 어떤 인터페이스의 구현체 사용을 선택할 것인지이다.

다시 말해 UserDao와 구체 클래스 사이의 관계를 설정해주는 것에 관한 관심이다. 이를 분리해야 아름답게 확장할 수 있다.

UserDao의 클라이언트가 적어도 하나는 존재한다. 여기서 클라이언트는 UserDao를 사용하는 오브젝트를 의미한다.

클라이언트 오브젝트가 UserDao와 ConnectionMaker 구현 클래스 관계를 결정해주는 기능을 분리해서 두기 적절한 곳이다.

오브젝트 사이의 관계가 형성되기 위해서는 만들어진 오브젝트가 있어야 한다.

생성자를 직접 호출해 만드는 방법도 있지만 오브젝트는 메서드 파라미터 등을 통해 전달 가능하니 외부에서 만들어진 것을 가져오는 방법도 있다.

그렇게 파라미터로 제공받은 오브젝트가 파라미터의 인터페이스에 구현체라면 어떤 클래스인지 신경쓰지 않아도 된다.

이를 통해 런타임 시에 오브젝트 사이의 관계가 맺어진다.

D사든 N사든 B사든 클라이언트에서 적절한 구현 클래스의 의존관계만 맺어주면 된다.

따라서, DB 접근 방식이나 코드에 변경이 생기더라도 UserDao는 영향이 없으며, 추가적으로도 자유로운 확장이 가능하다.

### 1.3.4 원칙과 패턴

#### 개방 폐쇄 원칙(OCP)
OCP를 간단히 정의하면 "확장에는 열려있고 변경에는 닫혀있어야 한다" 이다.

벤더사가 늘더라도, UserDao에 변경을 주지 않고 ConnectionMaker만 추가하여 확장할 수 있다.

인터페이스를 통해 제공되는 확장 포인트는 확장을 위해 개방되어 있고, 인터페이스를 이용하는 클래스는 굳게 폐세되어 있다.

well-design OOP class는 OCP를 잘 준수하고 있다.


#### 높은 응집도와 낮은 결합도
응집도가 높다는 것은 하나의 모듈, 클래스가 단일 책임 또는 관심사에 집중하고 있다는 의미이다.
불필요하거나 직접 관련이 없는 외부 관심과 책임이 얽혀있지 않고, 공통 관심사끼리만 모여있다.


책임과 관심사가 다른 오브젝트 또는 모둘과는 낮은 결합도, 즉 느슨하게 연결해주는 것이 바람직하다.
느슨한 연결은 관계를 유지하기 위해 꼭 필요한 최소한의 방법만 간접적으로 제공하고, 그 외에는 독립적이고 알 필요가 없게 만들어주는 것이다.
결합도가 낮아지면 변화 대응 속도가 높아지고, 구성이 깔끔해지며 확장에도 편리하다.

결합도가 높아지면 변경에 따르는 비용과 버그가 발생할 가능성이 높아진다.

UserDao와 ConnectionMaker는 인터페이스를 통해 아주 느슨하게 연결되어 있는 상태이다.
UserDao는 구체적인 ConnectionMaker 구현 클래스에 대해 전혀 몰라도 된다.


## 1.4 제어의 역전 (IoC)
IoC 약자로 사용되는 `제어의 역전`이라는 용어는 상당히 오래 전부터 존재했던 개념이다.

IoC가 무엇인지 살펴보기 위해 UserDao 코드를 좀 더 개선해보자.

### 1.4.1 오브젝트 팩토리
`UserDaoTest`는 태초에 UserDao 기능이 잘 동작하는지를 위해 존재했는데, 현재는 `ConnectionMaker`의 어느 구현 클래스를 사용할지 결정하는 역할을 엉겁결에 떠맡게 되었다.

이 또한 성격이 다른 책임과 관심사가 겹쳐있기 때문에 분리를 해야 한다.

분리 대상은 `UserDao`와 `ConnectionMaker`의 구현 오브젝트를 만드는 것과, 앞에 두 오브젝트가 연결되어 사용되도록 관계를 맺어주는 것이다.

#### 팩토리

```java
public class DaoFactory {
    public UserDao userDao() {
        DConnectionMaker connectionMaker = new DConnectionMaker();
        return new UserDao(connectionMaker);
    }
}

public class UserDaoTest {
    public static void main(String[] args) {
        UserDao userDao = new DaoFactory().userDao();
    }
}
```

ConnectionMaker를 생성하고 UserDao 생성, 의존 관계 형성하는 관심사를 DaoFactory에 분리하였다.

이제 UserDaoTest는 UserDao가 어떻게 만들어지는지, 어떻게 초기화되는지 관심을 쓰지 않아도 된다.

그저 팩토리로부터 UserDao 오브젝트를 반환받고, 본인 관심사인 테스트에만 집중할 수 있게 되었다.

#### 설계도로서의 팩토리
UserDao와 ConnectionMaker는 각 애플리케이션의 핵짐 로직을 담당하고, DaoFactory는 애플리케이션 오브젝트들을 구성하고 관계를 정의하는 책임을 맡고 있다.

전자가 실질적인 로직을 담당하는 컴포넌트라면, 후자는 애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의한 설계도 같은 역할을 한다고 볼 수 있다.

이제 벤더사에 UserDao를 공굽할 때, UserDao와 ConnectionMaker와 함께 DaoFactory도 함께 제공한다.

새로운 ConnectionMaker 구현 클래스로 변경이 필요하면 DaoFactory를 수정한다. 우리의 코어 기술인 UserDao는 변경하지 않아도 되며, 외부 요인으로부터 보호되고 있다. 동시에 DB 연결 방식은 자유롭게 확장이 가능하다.

DaoFactory를 분리하여 얻는 장점은 매우 다양하고, 그중에서도 애플리케이션 컴포넌트 역할을 하는 오브젝트와 애플리케이션 구조를 결정하는 오브젝트를 분리했다는 점이 가장 의미있다.


#### 1.4.3 제어권의 이전을 통한 제어관계 역전
제어의 역전은 프로그램의 제어 흐름 구조가 뒤바뀌는 것을 의미한다. 

제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 생성하지도, 선택하지도 않는다. 또한 자신도 어떻게 만들어지고 어디서 사용되는지 알 수 없다.
모든 제어권한을 자신이 아닌 다른 대상에게 위임하기 때문이다.

프레임워크도 제어의 역선 개념이 적용된 대표적인 기술이다. 프레임워크를 이해하려면 라이브러리와 프레임워크의 차이를 알아야 한다.

라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어하고, 필요할 때 능동적으로 라이브러리를 사용한다.

프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다. 보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 코드를 사용하도록 만드는 방식이다.

제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요하다.

스프링은 IoC를 모든 기능의 기초가 되는 기반 기술로 삼고 있으며, IoC를 극한까지 적용하고 있는 프레임워크이다.

## 1.5 스프링의 IoC
스프링의 핵심을 담당하는 것은 빈 팩토리 또는 애플리케이션 컨텍스트라고 불리우는 것이다. 
이 두 가지는 우리가 만든 DaoFactory가 하는 일을 좀 더 일반화한 것이라고 볼 수 있다.

### 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC
#### 애플리케이션 컨텍스트와 설정정보
스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈(Bean)이라고 한다.

스프링 빈은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 가리키는 말이다.

스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리라고 부르며, 보통 빈 팩토리를 확장한 애플리케이션 컨텍스트를 주로 사용한다.

애플리케이션 선텍스트는 IoC 방식을 따라 만들어진 일종의 빈 팩토리이다. 빈 팩토리와 애플리케이션 컨텍스트는 동일하다고 생각할 수 있다.

빈 팩토리는 보통 빈을 생성하고 관계를 설정하는 IoC 기본 기능에 초점을 맞추어 말하고, 애플리케이션 컨텍스트는 애플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC 엔진이라는 의미가 좀 더 부각된다고 볼 수 있다.

#### DaoFactory를 사용하는 애플리케이션 컨텍스트
스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스로 인식할 수 있도록 `@Configuration`을 추가하고, 오브젝트 생성 메서드에는 `@Bean` 어노테이션을 추가한다.

두 가지 어노테이션만으로 스프링 프레임워크의 빈 팩토리 또는 AC가 IoC 방식의 기능을 제공할 때 사용할 수 있는 설정정보로 만들 수 있다.

`getBean()` 메서드는 AC의 오브젝트를 요청하는 메서드이다. getBean의 파라미터 이름은 빈의 이름(메서드 이름)을 뜻한다.

메서드 이름을 사용하는 이유는 동일한 빈(클래스)을 생성하는 방식이나 구성을 다르게 가져갈 수 있기 때문이다.

### 1.5.2 애플리케이션 컨텍스트의 동작방식
AC는 ApplicationContext 인터페이스를 구현하고, ApplicationContext는 빈 팩터리가 구현하는 BeanFactory 인터페이스를 상속했으므로 AC는 일종의 빈 팩토리인 셈이다.

ApplicationContext는 빈의 생성정보와 연관관계 정보를 별도의 설정정보(@Configuration)를 통해 얻는다.

AC는 @Conguration 클래스를 설정정보로 등록하고 @Bean이 붙은 메서드의 이름을 가져와 빈 목록을 만든다.


### 1.5.3 스프링 IoC의 용어 정리
#### 빈(Bean)
스프링이 IoC 방식으로 관리하는 오브젝트를 의미한다. 스프링이 직접 생성과 제어를 담당하는 오브젝트만을 빈이라고 부른다.

#### 빈 팩토리(Bean Factory)
스프링의 IoC를 담당하는 핵심 컨테이너를 말한다.
빈을 등록/생성/조회/반환하고 그 외 부가적인 빈을 관리하는 기능을 담당한다.
보통은 빈 팩토리를 바로 사용하기 보다는 이를 확장한 애플리케이션 컨텍스트를 이용한다.

#### 애플리케이션 컨텍스트(Application Context)
빈 팩토리를 확장한 IoC 컨테이너이다. 빈 팩토리는 주로 빈의 생성과 제어의 관점에서 이야기하고, 애플리케이션 컨텍스트는 스프링이 제공하는 애플리케이션 지원 기능을 모두 포함해 이야기하는 것이라고 보면 된다.

ApplicationContext는 BeanFactory를 상속한다.

#### 설정정보/설정 메타정보
스프링의 설정정보란 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보를 의미한다.


#### 컨테이너 또는 IoC 컨테이너
IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 IoC 컨테이너라고 한다.

애플리케이션 컨텍스트는 Application Context 인터페이스를 구현한 오브젝트를 가르키며, 애플리케이션 컨텍스트 오브젝트는 하나의 애플리케이션에서 보통 여러 개가 만들어져 사용된다.
이를 통틀어 스프링 컨테이너라고 부를 수 있다.

#### 스프링 프레임워크
스프링 프레임워크는 IoC 컨테이너, 애플리케이션 컨텍스트를 포함해 스프링이 제공하는 모든 기능을 통틀어 말할 때 주로 사용한다.

## 1.6 싱글톤 레지스트리와 오브젝트 스코프
다음 내용을 살펴보기 전에 먼저 오브젝트의 `동일성`과 `동등성`에 대한 개념을 살펴보고 들어가자.

```markdown
동일성은 오브젝트의 주소값이 일치하는지, 동등성은 오브젝트의 정보가 일치하는지를 의미한다.
두 오브젝트가 동일하다면, 같은 오브젝트이기 때문에 하나의 오브젝트란 말이다.
자바 클래스를 만들 때 equals() 메서드를 재정의하지 않으면 최상위 클래스인 Object 클래스의 equals() 메서드를 사용한다.
Object 클래스의 equals()는 동일성을 비교한다. 
```

### 1.6.1 싱글존 레지스트리로서의 애플리케이션 컨텍스트
스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.

여기서 싱글톤은 디자인 패턴의 싱글톤과 비슷한 개념이지만 내부적인 구현 방법에는 차이가 있다.

#### 서버 애플리케이션과 싱글톤
근데.. 스프링은 왜 빈을 싱글톤으로 만드는 것일까?

스프링의 주 적용 대상은 엔터프라이즈급의 서버환경이며 실제로 대부분 서버환경에서 사용된다.

만약 TPS가 몇천이 되는 상황이고, 요청당 오브젝트 생성이 5번을 이뤄야 한다면, 아마 몇천x5.. 오브젝트 생성하고 소멸하고.. 가비지 컬렉터가 울부짖을 수 있다.

따라서 서버환경에서는 서비스 싱글톤의 사용이 권장된다.

하지만 디자인 패턴의 싱글톤 패턴은 사용하기 까다롭고 여러가지 문제점이 있기 때문에 안티패턴으로 부르는 사람도 있다.

#### 싱글톤 패턴의 한계
아래는 자바에서 싱글톤을 구현하는 방법이다.

- 클래스 밖에서 오브젝트를 생성하지 못하도록 생성자의 접근제어자를 private으로 한다.
- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의한다.
- 스태틱 팩토리 메서드인 `getInstance()`를 만들고 이 메서드가 최초 호출 시에 한번 오브젝트를 만들고 변수에 담는다.
- 한번 오브젝트가 만들어지고 난 후에는 getInstance() 메서드를 통해 이미 만들어진 스태틱 필드의 오브젝트를 반환한다.

싱글톤 패턴 구현 방식에는 다음과 같은 문제가 있다.
##### private 생성자를 갖고 있기 때문에 상속할 수 없다
싱글톤 패턴은 생성자를 private으로 제한한다. 오직 싱글톤 클래스만이 자신의 오브젝트를 생성한다. 때문에 상속이 불가하며, 객체지향의 장점인 다형성 적용이 어렵다.

##### 싱글톤은 테스트하기 힘들다
싱글톤은 만들어지는 방식이 제한적이라 테스트에서 사용될 때 목 오브젝트 등으로 대체하기 어렵다. 
초기화 과정에서 생성자 등을 통해 사용할 오브젝트를 다이나믹하게 중비하기도 힘들다.

#### 싱글톤 레지스트리
자바의 기본적인 싱글톤 패턴 구현 방법에는 여러 가지 문제점이 있기 때문에, 스프링은 싱글톤 레지스트리로 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.

싱글톤 레지스트리의 장점은 static, private 사용 없이 평범한 자바 클래스를 싱글톤으로 할용하게 해준다.

public을 가질 수 있고, 자유롭게 오브젝트를 만들고 생성자 파라미터를 통해 사용할 오브젝트를 연결해줄 수도 있다.

가장 중요한 것은 스프링이 지지하는 객체지향적 설계, 디자인 패턴 등을 적용하는 데 아무런 제약이 없다는 부분이다.

### 1.6.2 싱글톤과 오브젝트 상태
스프링의 빈은 싱글톤이자 고유하기 때문에 상태 관리에 주의해야 한다.

비단 스프링의 문제는 아니지만, 인스턴스 변수의 상태 변경에 각별히 신경써야 한다.

### 1.6.3 스프링 빈의 스코프
스프링 빈의 기본 스코프는 싱글톤이다. 싱글톤은 컨테이너 내에 한 개의 오브젝트만 만들어지고 강제로 제거하지 않는 한 계속 유지된다.

싱글톤 외 스코프는 프로토타입 스코프가 있다. 프로토타입 스코프는 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어준다.

그 외 요청스코프, 세션스코프도 있다.